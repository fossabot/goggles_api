# Group Badges

# Badge details [/api/v3/badge/{id}]

+ Model (application/json)

        {
            "id": 124947,
            "number": "04204788",
            "season_id": 191,
            "swimmer_id": 142,
            "team_id": 1,
            "category_type_id": 1320,
            // [...]
            "created_at": "2019-10-16T00:00:00.000Z",
            "updated_at": "2019-10-16T00:00:00.000Z",
            "entry_time_type_id": 5,
            "team_affiliation_id": 5727,
            "final_rank": null,
            "off_gogglecup": false,
            "fees_due": false,
            "badge_due": false,
            "relays_due": false,

            // Embedded associated Swimmer:
            "swimmer": {
                "id": 142,
                "lock_version": 1,
                "last_name": "ALLORO",
                "first_name": "STEFANO",
                "year_of_birth": 1969,
                "phone_mobile": null,
                "phone_number": null,
                "e_mail": null,
                "nickname": "",
                "associated_user_id": 1,
                "gender_type_id": 1,
                // [...]
                "complete_name": "ALLORO STEFANO",
                "year_guessed": false
            },

            // Embedded associated TeamAffiliation:
            "team_affiliation": {
                "id": 5727,
                "number": "04200002",
                "name": "CSInuoto OberFerrari",
                "compute_gogglecup": true,
                "team_id": 1,
                "season_id": 191,
                // [...]
                "autofilled": false
            },

            // Embedded associated Season:
            "season": {
                "id": 191,
                // [...]
                "description": "Circuito regionale Emilia master CSI 2019/2020",
                "begin_date": "2019-10-01",
                "end_date": "2020-09-30",
                "season_type_id": 2,
                "created_at": "2019-10-16T07:20:51.000Z",
                "updated_at": "2019-10-16T07:20:51.000Z",
                "header_year": "2019/2020",
                "edition": 20,
                "edition_type_id": 5,
                "timing_type_id": 2,
                "rules": null,
                "has_individual_rank": true,
                "badge_fee": "10.0"
            },
            "team": {
                "id": 1,
                // [...]
                "created_at": "2014-10-19T00:00:00.000Z",
                "updated_at": "2014-10-19T16:04:16.000Z",
                "name": "CSI NUOTO OBER FERRARI ASD",
                "editable_name": "CSI NUOTO OBER FERRARI ASD",
                "address": "Team HQ address",
                "zip": "",
                "phone_mobile": "",
                "phone_number": "",
                "fax_number": null,
                "e_mail": "contact.email@this.is.just.a.fake.domain.com",
                "contact_name": "Marco Ligabue",
                "notes": "whatever the team manager needs to write here",
                "name_variations": null,
                "city_id": 37,
                // [...]
                "home_page_url": "",
            },
            "category_type": {
                "id": 1320,
                // [...]
                "code": "M50",
                "federation_code": "8",
                "description": "MASTER 50",
                "short_name": "M50",
                "group_name": "MASTER",
                "age_begin": 50,
                "age_end": 54,
                "is_a_relay": false,
                // [...]
                "season_id": 191,
                "is_out_of_race": false,
                "is_undivided": false
            },
            "entry_time_type": {
                "id": 5,
                "code": "U",
                // [...]
            }
        }


## find [GET]

The Badge instance matching the specified `id` returned as JSON.

The returned result includes these other 1st-level linked entities:
- `Swimmer`
- `TeamAffiliation`
- `Season`
- `Team`
- `CategoryType`
- `EntryTimeType`

:key: `Authorization` request header => valid JWT **required**


* * *


+ Parameters
    + id: 124947 (number, required) - Badge ID


+ Request ok (application/json)

    #### Examples

    ##### `curl` (Bash):

    ```bash
    $> curl -i -X GET -H "Content-Type: application/json" \
            -H 'Authorization: "Bearer VALID-SESSION-JWT"' \
            "<API_HOST:PORT>/api/v3/badge/124947"
    ```

    ##### `RestClient` (Ruby):

    ```ruby
    > res = RestClient::Request.execute(
                method: :get,
                url: 'localhost:3000/api/v3/badge/124947',
                headers: { "Authorization" => "Bearer VALID-SESSION-JWT" }
            )
    => <RestClient::Response 200 "{\"id\":12494...">
    ```

    * * *

    + Header

            Authorization: "Bearer VALID-SESSION-JWT"

+ Response 200

    [Badge details][]


+ Request not found (application/json)

    + Header

            Authorization: "Bearer VALID-SESSION-JWT"

+ Response 200 (application/json)

        null


+ Request bad JWT (application/json)

    All JWTs expire: see [Session API docs](#sessions-session-post) for info.

    + Header

            Authorization: "Bearer BAD-OR-EXPIRED-JWT"

+ Response 401 (application/json)

    + Header

            X-Error-Detail: "Invalid JWT token"

    + Body

            { "msg": "Unauthorized" }


+ Request no JWT (application/json)

+ Response 401 (application/json)

    + Header

            X-Error-Detail: "Missing JWT token"

    + Body

            { "msg": "Unauthorized" }



## edit [PUT]

Allows direct updates for the Badge number and other limited fields given the `id` of the row.

Returns 'true' on success, an empty result when not found.

:key: `Authorization` request header => valid JWT **required**


#### Body Attributes:

- `number` (string, **required**): Badge code or number
- `entry_time_type_id` (number): associated EntryTimeType ID for referencing default timings
    | _id_ | _code_ | _description_ |
    | --- | --- | --- |
    | 1 | `M` | manual |
    | 2 | `P` | personal |
    | 3 | `G` | GoggleCup |
    | 4 | `A` | preceding year |
    | 5 | `U` | last race |
- `fees_due` (boolean): 'true', the Swimmer has to pay additional meeting fees for the Championship; 'false', the Team provides
- `badge_due` (boolean): 'true', the Swimmer has to pay the badge registration; 'false', the Team provides
- `relays_due` (boolean): 'true', the Swimmer has to pay any relay event in the Championship; 'false', the Team provides


* * *


+ Parameters
    + id: 124947 (number) - Badge ID


+ Request ok (application/json)

    #### Examples

    ##### `curl` (Bash):

    ```bash
    $> curl -i -X PUT -H "Content-Type: application/json" \
            -H 'Authorization: "Bearer VALID-SESSION-JWT"' \
            -d '{"number": "A_NEW_OR_EXISTING_BADGE_CODE", \
                "entry_time_type_id": 1, "badge_due": "true"}' \
            "<API_HOST:PORT>/api/v3/badge/124947"
    ```

    ##### `RestClient` (Ruby):

    ```ruby
    > res = RestClient::Request.execute(
                method: :put,
                url: '<API_HOST:PORT>/api/v3/badge/124947',
                payload: {
                    number: 'A_NEW_OR_EXISTING_BADGE_CODE',
                    entry_time_type_id: 1,
                    badge_due: true
                },
                headers: { "Authorization" => "Bearer VALID-SESSION-JWT"}
            )
    => <RestClient::Response 200 "true">
    ```

    * * *

    + Header

            Authorization: "Bearer VALID-SESSION-JWT"

    + Body

            {
                "number": "A_NEW_OR_EXISTING_BADGE_CODE",
                "entry_time_type_id": 1,
                "fees_due": false,
                "badge_due": false,
                "relays_due": false
            }

+ Response 200 (application/json)

        true


+ Request not found (application/json)

    The row for the specified ID must be existing in order to be edited.

    + Header

            Authorization: "Bearer VALID-SESSION-JWT"

    + Body

            {
                "number": "A_NEW_OR_EXISTING_BADGE_CODE",
                "entry_time_type_id": 1,
                "fees_due": false,
                "badge_due": false,
                "relays_due": false
            }

+ Response 200 (application/json)

        null


+ Request bad JWT (application/json)

    All JWTs expire: see [Session API docs](#sessions-session-post) for info.

    + Header

            Authorization: "Bearer BAD-OR-EXPIRED-JWT"

    + Body

            {
                "number": "A_NEW_OR_EXISTING_BADGE_CODE",
                "entry_time_type_id": 1,
                "fees_due": false,
                "badge_due": false,
                "relays_due": false
            }

+ Response 401 (application/json)

    + Header

            X-Error-Detail: "Invalid JWT token"

    + Body

            { "msg": "Unauthorized" }


+ Request no JWT (application/json)

            {
                "number": "A_NEW_OR_EXISTING_BADGE_CODE",
                "entry_time_type_id": 1,
                "fees_due": false,
                "badge_due": false,
                "relays_due": false
            }

+ Response 401 (application/json)

    + Header

            X-Error-Detail: "Missing JWT token"

    + Body

            { "msg": "Unauthorized" }


# Badge list [/api/v3/badges{?page,per_page,team_id,team_affiliation_id,season_id,swimmer_id}]

+ Model (application/json)

    + Header

            Link: "<API_HOST:PORT/api/v3/badges?page=60&team_id=1>; rel=\"last\", <http://localhost:3000/api/v3/badges?page=2&team_id=1>; rel=\"next\""
            Total: 1483
            Per-Page: 25
            Page: 1

    + Body

            [
                // Badge details 1
                {
                    "id": 124947,
                    // [...]
                },

                // Badge details 2
                {
                    "id": 124948,
                    // [...]
                },

                // [...]
            ]


## badges [GET]

The list of Badges associated to the specified filtering values,
returned as JSON and optionally filtered by any or all from:

- `team_id`
- `team_affiliation_id`
- `season_id`
- `swimmer_id`

Optional pagination parameters for the request:

- `page`: current/selected page cursor
- `per_page`: total items per data page (default: 25)

:key: `Authorization` request header => valid JWT **required**

### Pagination

Pagination links will be returned in the `Link` _response header_, for all arrays with
more than 25 results.

Typical `Link` header format (single String, separated by COMMA+BLANK):

    "<REQ_URL_FOR_NEXT_PAGE>; rel=\"next\", <REQ_URL_FOR_LAST_PAGE>; rel=\"last\""


* * *


+ Parameters
    + team_id: 1 (number, optional) - associated Badge ID
    + swimmer_id: 142 (number, optional) - associated Swimmer ID
    + team_affiliation_id: 5727 (number, optional) - associated TeamAffiliation ID
    + season_id: 1 (number, optional) - associated Season ID
    + page: 1 (number, optional) - pagination: selected page
        + Default: 1
    + per_page: 25 (number, optional) - pagination: desired total rows per page
        + Default: 25


+ Request ok (application/json)

    ### Examples

    #### `curl` (Bash):

    ```bash
    $> curl -i -X GET -H "Content-Type: application/json" \
            -H 'Authorization: "Bearer VALID-SESSION-JWT"' \
            "<API_HOST:PORT>/api/v3/badges?team_id=1"
    ```

    #### `RestClient` (Ruby):

    _(Note that due to how the current version of RestClient handles the actual query parameters of the request,
    the `params` hash needs to be specified inside the `headers` hash.)_

    ```ruby
    > res = RestClient::Request.execute(
                method: :get,
                url: '<API_HOST:PORT>/api/v3/badges',
                headers: {
                    "Authorization" => "Bearer VALID-SESSION-JWT",
                    params: { team_id: 1 }
                }
            )
    => <RestClient::Response 200 "[{\"id\":12494...">
    ```

    * * *

    + Header

            Authorization: "Bearer VALID-SESSION-JWT"

+ Response 200

    [Badge list][]


+ Request not found (application/json)

    + Header

            Authorization: "Bearer VALID-SESSION-JWT"

+ Response 200 (application/json)

        []


+ Request bad JWT (application/json)

    All JWTs expire: see [Session API docs](#sessions-session-post) for info.

    + Header

            Authorization: "Bearer BAD-OR-EXPIRED-JWT"

+ Response 401 (application/json)

    + Header

            X-Error-Detail: "Invalid JWT token"

    + Body

            { "msg": "Unauthorized" }


+ Request no JWT (application/json)

+ Response 401 (application/json)

    + Header

            X-Error-Detail: "Missing JWT token"

    + Body

            { "msg": "Unauthorized" }
